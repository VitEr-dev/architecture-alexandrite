«Архитектурное решение по кешированию»

В соответствии с условиями задания, проблема возникает у Операторов. Проблема в том, что Операторы не могут оперативно обновить список новых заказов и взять в работу конкретный заказ, и в целом проблема из-за низкой скорости работы [MES: React/TypeScript]. Информация о том, что клиенты жалуются на неудовлетворительную скорость выполнения заказа (как я понял – клиент говорит о производстве реального продукта) — это своего рода повышение приоритета проблемы Операторов. 

В процессе распределения заказов Операторам (подход: кто первый взял, того и заказ) участвуют: АРМ Оператора (browser), фронтенд [MES: React/TypeScript], бекэнд [MES API: C#], База данных [MES db: PosgreSQL]. Фронтенд, бекэнд, БД – каждый развернут на одном инстансе. Запросы/ответы в синхронном режиме. 

Наиболее проблемным выглядит [MES API: C#]. В рамках бекэнда реализован большой функционал: обработка запросов на чтение и запись 3D моделей, загрузка 3D модели по внешнему API, расчет стоимости изготовления изделия по 3D модели, ведение реестра заказов и назначение исполнителя (Оператора). Выполнение данного функционала требует значительных ресурсов «железа», но и этого может оказаться недостаточно при возрастающей нагрузке на сервис.  

Для решения проблемы Операторов (повышение быстродействия сервиса), идеально, проработать и реализовать в комплексе несколько решений:
1 Клиентское кеширование и Кеширование данных их БД PosgreSQL
2 «Расшивка узкого места» [MES API: C#]. Как вариант, развернуть компонент на нескольких инстансах таким образом, чтобы функционал оценки производства по 3D моделям выполнялся на одном инстансе, функционал обработки заказов – на другом (потребуется доработка). Настроить асинхронное взаимодействие по загрузке и обсчету 3D моделей с помощью брокера сообщений. 
3 Оптимизировать БД PosgreSQL, запросы/ответы на чтение и запись. 


Клиентское и серверное кеширование само по себе может значительно ускорить работу сервиса Оператора, но если делать все 3 пункта, то эффект будет превосходить эффект от реализации только кеширования. 
Далее прорабатываем только кеширование. 

Мотивация

Кеширование – один из ключевых методов повышения скорости работы высоконагруженного сервиса, за счет оптимизации исполнения запросов/ответов сервиса на чтение и на запись данных с использованием технологии хранения частоиспользуемых данных в быстродоступной памяти (кеше) для ускорения доступа к ним при выполнении запросов в будущем. 

Предлагаемое решение 

Внедряем клиентское кеширование (браузеры Операторов) и Серверное кеширование (БД PosgreSQL)

Клиентское кеширование (браузеры Операторов)

Для Оператора список заказов является ключевой информацией для работы, кеширование в браузере на стороне оператора позволит сохранять в кеше перечень заказов и при запросе к ним обращаться к кешу браузера, в качестве обновлений с сервера получать новые/измененые заказы. Таким образом время загрузки страницы с заказами будет сокращено. 

Заголовок HTTP документа Cache-Control: max-age = x (x длительность определяется из бизнес-задачи), private (полагаю, что Операторы работают индивидуально), no-cache (проверка актуальности данных в кеше, запрос к кешу на стороне сервера)

Здесь важный момент, как организована информационная безопасность: АРМы операторов в локальной сети или нет, авторизация/аутентификация/аудит пользователей, антивирус на АРМ, использование протокола https. Решение должно быть максимально защищено от утечки чувствительных данных и несанкционированного доступа. 

Серверное кеширование (БД PosgreSQL)

Серверное кеширование необходимо для оптимизации и ускорения операций чтения и записи из/в БД. Будем использовать комбинацию: встроенные механизмы кеширования PosgreSQL, расширения для PosgreSQL и redis.

Для  чтения данных будем использовать паттерн Read-Through, при запросе данных, пользователь обращается в кеш, кеш обращается в БД, кеш получает данные, возвращает ответ пользователю. При использовании данного паттерна преимуществами решения являются: упрощение логики приложений (приложению не требуется проверять данные в кеше и загружать данные из БД при кеш-промахе, вся логика инкапсулирования реализуется в слое кеша); снижение задержек времени при кеш-промахе (кеш сам загружает данные из БД и возвращает их клиенту, вместо того, чтобы приложение делало два запроса, в кеш и в БД); автоматическое заполнение кеша (кеш постепенно заполняется наиболее востребованными данными, уменьшается количество повторных кеш-промахов); хорошо сочетается с паттерном Write-Trough (когда используется данный паттерн, данные в кеше всегда актуальны, и Read-Through просто возвращает их клиенту из кеша). Есть недостатки: первая загрузка данных медленная. 

Для записи данных будем использовать паттерн Write-Through. Логика данного паттерна для операций записи похожа на логику Read-Through. Операция записи проходит через кеш и через БД последовательно: приложение обновляет кеш, кеш немедленно обновляет БД, БД обновляется в соответствие с задачей, ответ об успешной операции возвращается клиенту. У данного паттерна есть преимущества, данные между БД и кеше всегда будут синхронизированы. При использовании данного паттерна преимуществами решения являются: средняя скорость записи (у паттерна Write-Behind запись в асинхронном режиме, скорость выше); наиболее надежный паттерн, строгая согласованность данных; защита от потери данных при сбоях; упрощение логики приложения. Есть недостатки: не самая высокая скорость записи по сравнению с паттерном Write-Behind; операции записи создает нагрузку на БД. 

Диаграмма последовательности действий представлена в файле:

https://drive.google.com/file/d/1bitj0PqJd1ZFeItkQX7UHyjYW2wZg_pL/view?usp=sharing

Описание диаграммы:

sequenceDiagram
    participant Browser
    participant Frontend as Frontend(React/TS)
    participant Backend as Backend(C#)
    participant Redis
    participant PostgreSQL
    1. Инициация изменения статуса заказа
    Browser->>Frontend: Изменение статуса заказа {order_id}
    2. Отправка запроса на бэкенд
    Frontend->>Backend: PATCH /api/orders/{order_id} (status=shipped)
    3. Обновление в БД (сначала обновление БД, потом инвалидация кеша)
    Backend->>PostgreSQL: UPDATE orders SET status='shipped' WHERE order_id={order_id}
    4. Подтверждение от БД
    PostgreSQL-->>Backend: Подтверждение
    5. Очистка кеша. Инвалидируем конкретный заказ
    Backend->>Redis: Удалить order:{order_id} и orders:list
    6. подтверждение от Redis (ключи успешно удалены)
    Redis-->>Backend: Подтверждение
    7. Ответ клиенту
    Backend-->>Frontend: 200 OK
    8. Клиентская инвалидация
    Frontend->>Browser: Инвалидирует локальный кеш для /api/orders*
    9. Автоматический refetch по ключу (выполняется React Query)
    Browser-->>Frontend: Запрашивает актуальные данные

Стратегия инвалидации кеша

В качестве стратегии инвалидации кеша предлагается инвалидация по времени, что позволит минимизировать объем инвалидации данных в  кеше и обновлять только необходимые данные. В нашей задаче обновления требуют status исполнения заказа по ключу order_id.  